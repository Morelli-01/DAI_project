import socket
import threading
import time
from multiprocessing import Value
from time import sleep
import json
import numpy as np
import paho.mqtt.client as mqtt
import uuid
from datetime import datetime
from sortedcontainers import SortedDict

WELL_KNOWN = '/.well-known'
ADD_DEVICE_TOPIC = WELL_KNOWN + '/add'
REMOVE_DEVICE_TOPIC = WELL_KNOWN + '/del'


def extract_token(decoded_data):
    return int(decoded_data[decoded_data.find('{') + 1: decoded_data.find('}')])


class BaseWorker():
    def __init__(self, host='localhost', port=1883, shared_var=None, debug=False, id_client=None):
        self.host = host
        self.port = port
        self.shared_var = shared_var
        self.debug = debug
        if id_client == None:
            self.id_client = str(uuid.uuid4())
        else:
            self.id_client = str(id_client)
        self.event_history = []

        self.row = None
        self.cols = None
        self.proc_index = None

    def assign_work(self, row: np.ndarray, cols: np.ndarray, proc_index):
        self.row = row
        self.cols = cols.T
        self.proc_index = proc_index

    def log_event(self, msg):
        msg = f"[{str(datetime.now().time())[:13]}] {msg}"
        if self.debug:
            print(msg)
        self.event_history.append(msg)


class RingWorker(threading.Thread, BaseWorker):
    def __init__(self, host="localhost", port=None, debug=False, next_host=("", None), shared_var=None, id_client=None):
        threading.Thread.__init__(self)
        if id_client == None:
            id_client = self.name
        BaseWorker.__init__(self, host=host, port=port, debug=debug, shared_var=shared_var, id_client=id_client)
        self.next_host = next_host
        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.s.bind((self.host, self.port))
        self._stop_event = threading.Event()
        self.cycles_counter = 1
        self.result_available = 0
        self.log_event("Socket is ready!")
        self.stop_ = False
        self.work_done = False

    def token_passing_(self, result=None):
        try:
            prev_conn, prev_addr = self.s.accept()
            data = prev_conn.recv(1024)
            decoded_data = data.decode()
            token_value = extract_token(decoded_data)
            prev_conn.close()

            self.log_event(f"{self.name} received: {decoded_data}")

            if bool(self.result_available):
                self.log_event(f"{self.name} is doing some job...")
            else:
                self.log_event('passing token')

            if bool(self.result_available):
                self.shared_var[self.proc_index] = result
                token_value -= 1
                self.result_available -= 1

            if decoded_data.__contains__(self.name):
                self.cycles_counter += 1

            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as send_socket:
                send_socket.connect(self.next_host)
                decoded_data = decoded_data[:decoded_data.find('{') + 1] + str(token_value) + decoded_data[
                                                                                              decoded_data.find('}'):]
                data = decoded_data.encode()
                send_socket.sendall(data)

            if token_value == 0:
                self.work_done = True

        except BlockingIOError:
            pass

    def run(self):
        self.s.listen()
        self.s.setblocking(False)
        i = 0
        result = np.zeros((self.cols.shape[0]))
        while not self.work_done:

            self.token_passing_(result=result)

            if i >= result.shape[0]:
                continue
            result[i] = (self.row * self.cols[i]).sum()
            i += 1
            if i >= result.shape[0]:
                self.result_available += 1
                self.s.setblocking(True)

    def stop(self):
        self._stop_event.set()

    def starter(self, token_value):
        self.start()

        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as send_socket:
            send_socket.connect(self.next_host)
            send_socket.sendall(f"Token {{{token_value}}} generated by {self.name}".encode())


class MqttWorker(threading.Thread, BaseWorker):
    def __init__(self, id_client=None, broker_host='localhost', broker_port=1883, debug=False, shared_var=None):
        if id_client == None:
            id_client = str(uuid.uuid4())
        threading.Thread.__init__(self)
        BaseWorker.__init__(self, host=broker_host, port=broker_port, debug=debug, shared_var=shared_var,
                            id_client=id_client)

        self.client_ = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2, client_id=self.id_client)
        self.client_.on_connect = self.on_connect
        self.client_.on_message = self.on_message
        self.client_.connect(host=self.host, port=self.port, keepalive=6000)
        self.workers_ = {'ids': []}
        self.critical_queue_ = SortedDict()
        self.n_confirmation_ = 0
        self.confirmation_ids_ = []
        self.work_done = False

        msg = {'id': self.id_client}
        self.client_.publish(topic=ADD_DEVICE_TOPIC, payload=json.dumps(msg).encode())
        self.client_.subscribe(topic='/' + self.id_client + '/#', qos=2)

    def on_connect(self, client, userdata, flags, reason_code, properties):
        self.log_event(f"{self.id_client} has connected with result code {reason_code}")

    def on_message(self, client, userdata, msg):
        decoded_msg = json.loads(msg.payload.decode())
        self.log_event(self.id_client + " [received msg]: " + msg.topic + " " + str(msg.payload))

        if msg.topic == WELL_KNOWN and msg.retain:
            self.workers_['ids'] = decoded_msg['ids']

        if msg.topic == f"/{self.id_client}/request":
            self.critical_queue_[float(decoded_msg['timestamp'])] = decoded_msg['id']
            self.client_.publish(topic=f"/{decoded_msg['id']}/response",
                                 payload=json.dumps({'id': self.id_client}).encode())
            self.log_event(f"{self.id_client}: sended response to {decoded_msg['id']}")

        if msg.topic == f"/{self.id_client}/response":
            if not self.confirmation_ids_.__contains__(decoded_msg['id']):
                self.confirmation_ids_.append(decoded_msg['id'])
                # self.log_event(f"{self.id_client}: received response from {decoded_msg['id']}")

        if msg.topic == f"/{self.id_client}/release":
            self.critical_queue_.pop(float(decoded_msg['timestamp']))

    def del_device(self):
        msg = {'id': self.id_client}
        self.client_.publish(topic=REMOVE_DEVICE_TOPIC, payload=json.dumps(msg).encode())
        self.log_event("Removed from service-dicovery")

    def lamport_access(self, result):
        self.client_.subscribe(WELL_KNOWN, qos=2)
        while self.workers_['ids'].__len__() == 0:
            self.client_.loop_read()
            self.client_.loop_write()
        self.client_.unsubscribe(WELL_KNOWN)

        request_msg = {
            'id': self.id_client,
            'timestamp': str(time.time())
        }
        self.critical_queue_[float(request_msg['timestamp'])] = request_msg['id']
        for id in self.workers_['ids']:
            if id == self.id_client:
                continue
            self.client_.publish(topic=f"/{id}/request", payload=json.dumps(request_msg).encode())
        self.log_event(f"{self.id_client}: critical section access requested with tm-{request_msg['timestamp']}")
        # sleep(2)

        while self.confirmation_ids_.__len__() != (self.workers_['ids'].__len__() - 1) or \
                list(self.critical_queue_.values())[0] != self.id_client:
            self.client_.loop_read()
            self.client_.loop_write()

        # do teh job
        self.log_event(f"{self.id_client}: got access to critical section({datetime.now().timestamp()})")
        # sleep(5)
        self.shared_var[self.proc_index] = result

        for id in self.workers_['ids']:
            if id == self.id_client:
                continue
            self.client_.publish(topic=f"/{id}/release", payload=json.dumps(request_msg).encode())
        self.log_event(f"{self.id_client}: released critical section")

    def stop(self):
        self.client_.disconnect()

    def run(self):
        i = 0
        result = np.zeros((self.cols.shape[0]))
        result_available = False
        while not self.work_done:

            if i < result.shape[0]:
                result[i] = (self.row * self.cols[i]).sum()
                i += 1

                if i == result.shape[0]:
                    self.log_event(f"{self.id_client}: The matmul prod is ready")
                    result_available = True

            if result_available:
                self.lamport_access(result)
                result_available = False
                self.work_done = True

            self.client_.loop_read()
            self.client_.loop_write()

        self.client_.loop_forever()


class MqttDeviceDiscovery(threading.Thread, BaseWorker):
    def __init__(self, broker_host='localhost', broker_port=1883, debug=False, id_client=None):
        threading.Thread.__init__(self)
        if id_client == None:
            id_client = str(uuid.uuid4())
        BaseWorker.__init__(self, host=broker_host, port=broker_port, debug=debug, shared_var=None, id_client=id_client)

        self.devices_ = []
        self.stop_ = True
        self.client_ = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2, client_id=self.id_client)
        self.client_.on_connect = self.on_connect
        self.client_.on_message = self.on_message
        self.client_.connect(host=self.host, port=self.port, keepalive=6000)
        self.client_.subscribe(topic=f"{WELL_KNOWN}/#")

    def on_message(self, client, userdata, msg):
        decoded_msg = json.loads(msg.payload.decode())
        self.log_event(f"{self.id_client} Received message from topic {msg.topic}:\n {msg.payload} ")

        if msg.topic == WELL_KNOWN and msg.retain:
            self.devices_ = decoded_msg['ids']

        if msg.topic == ADD_DEVICE_TOPIC:
            self.devices_.append(decoded_msg['id'])
            self.topic_update()

        if msg.topic == REMOVE_DEVICE_TOPIC:
            self.devices_.remove(decoded_msg['id'])
            self.topic_update()

    def topic_update(self):
        self.client_.publish(topic=WELL_KNOWN, payload=json.dumps({'ids': self.devices_}).encode(), qos=2, retain=True)

    def on_connect(self, client, userdata, flags, reason_code, properties):
        self.log_event(f"{self.id_client} has connected with result code {reason_code}")

    def stop(self):
        self.stop_ = True
        self.client_.disconnect()

    def run(self):
        self.stop_ = False
        while not self.stop_:
            self.client_.loop_read()
            self.client_.loop_write()
